"""Задания:
1) написать ф-ю, которая возвращает ф-ю повторения двух первых символов n раз
2) cоздать массив ф-й (с различными параметрами n) и применять все ф-ии поочередно к аргументу
3) применять все ф-ии поочередно к массиву аргументов"""

animal = 'мишка'
animals = ['зайка', 'мишка', 'бегемотик']

'''Будем применять функциональный стиль программирования'''


# 1) написать ф-ю, которая возвращает ф-ю повторения двух первых символов n раз

def gen_repeat(n):  # в параметры передаем кол во раз для повторения перевых двух символов

    def repeat(animal):
        return (animal[:2] + '-') * n + animal

    return repeat

print("#1")
test_1 = gen_repeat(1)
test_2 = gen_repeat(2)
print(test_1(animal))
print(test_2(animal))


# 2) cоздать массив ф-й (с различным ген_репит, а n будет меняться в диапазоне от 1 до 4, т.е, тест 1. тест 2 и тест 3
'''repetitions = [gen_repeat(n) for n in range(1, 4)]
print(repetitions)
# ==> [<function gen_repeat.<locals>.repeat at 0x0000026582AD2660>, <function gen_repeat.<locals>.repeat at
# 0x0000026582AD2700>, <function gen_repeat.<locals>.repeat at 0x0000026582AD27A0>]
# чтобы был нужный результат, мы можем воспользоваться фор или сделать еще одну списковую сборку
# сделаем списковую сборку
result = [func(animal) for func in repetitions]
print(result) # ==> ['ми-мишка', 'ми-ми-мишка', 'ми-ми-ми-мишка'] '''
print('\n',"#2")
repetitions = [gen_repeat(n) for n in range(1, 4)]
result = [func(animal) for func in repetitions]
print(result)
'''==>['за-зайка', 'ми-мишка', 'бе-бегемотик', 'за-за-зайка', 'ми-ми-мишка', 'бе-бе-бегемотик', 'за-за-за-зайка', 
'ми-ми-ми-мишка', 'бе-бе-бе-бегемотик']'''


#  3) применять все ф-ии поочередно к массиву аргументов"
"""Можно фором пройтись, и применить те функции к каждому элементы списка
Но также сделаем списковой сборкой, но необычной, нужно будет сделать двойной цикл. Мы будем применять 
функцию к какому либо аргументу. мы пока еще не знаем, мы будем генерировать с помощью двух циклов фор. 

Можно применять пока к простому x. Фанк будем брат из списка репетишнс/
А х - из списка энималс"""
# Теперь в этом списке будут результаты всех 3х функций, которые применились ко всем 3 аргументам из списка анималс
print('\n',"#3")
fin_result = [func(x) for func in repetitions for x in animals]
print(fin_result)
# ==> ['за-зайка', 'ми-мишка', 'бе-бегемотик', 'за-за-зайка', 'ми-ми-мишка', 'бе-бе-бегемотик',
#      'за-за-за-зайка', 'ми-ми-ми-мишка', 'бе-бе-бе-бегемотик']
# А если поменять порядок откуда берем данные, то:
fin_result = [func(x) for x in animals for func in repetitions]
print(fin_result)
# ==> ['за-зайка', 'за-за-зайка', 'за-за-за-зайка', 'ми-мишка', 'ми-ми-мишка', 'ми-ми-ми-мишка',
#      'бе-бегемотик', 'бе-бе-бегемотик', 'бе-бе-бе-бегемотик']
"""Порядок имеет значение. Либо мы перебираем все х и применяем их к одной функции", либо сначала перебираем все наши 
функции и применяем к одному х (аргументу)"""

#  4) Задача - есть ф-я, которая возвр рез-т введения числа a в степень b
# Нужно ускорить ее, чтобы она неделала повторные вычисления
"""идея такая:
 Создаем пустой словарик
 Затем в этот словарь  будут попадать кортеж из значений параметров как ключ, и результат как значение
 при первом вычислении словарь пустой, и в него запишутся данные
 затем. если данные будут отличные от записанных. то они запишутся в словарь
 а если повторятся, то выведется только значение из имеющегося уже в словаре"""
def memoize_func(f): # декоратор,длф ускорения
    mem = {}

    def wrapper(*args):# ф-я-заменитель будет добавлять лио брать значени из нашего словарика
        print(f"Выполение функции с аргументами {args}, внутреннняя память {mem}")
        if args  not in mem:
            mem[args] = f(*args)
            return f'Функция выполнилась, ответ = {mem[args]}'
        else:
            return f'Функция уже была выполнена раньше, ответ = {mem[args]}'
    return wrapper

@memoize_func
def func(a,b):
    print(f"Выполняем ф-ю с аргументами {a} и {b}")
    return a**b

print('\n',"#4")
print(func(3,5), '\n')
print(func(3,4), '\n')
print(func(3,2), '\n')
print(func(3,5), '\n')
print(func(3,4), '\n')
print(func(3,5), '\n')


