"""Мы можем не только заменять функцию, ранее нами разработанную, но и варьировать способы её замены.
Это позволяет изменять или дополнять функциональность декораторов, создавая несколько декораторов из одного."""

# # Шаблон для генератора, который генерирует декораторы
# def func_gen_dec(*p):
#     """ ф которая генер-ет дек-тор, на вход принимю параметры,
# котор будут исп. во внутр-х ф-х потому что у нас работает замыкание переменных """
#     def dec(func, *p):      # сама ф-декоратор, прин на вход функцию и другие параметры
#         def wrapper(*args, **kwargs):    # стандартная ф-заменитель
#             result = func(*args, **kwargs)
#             return result
#         return wrapper
#     return dec
"""Вызываться будет не в этом порядке: когда у нас будет создаваться генератор, мы его определим в dec(func), 
мыего сраду и вернули  return dec. Потом уже когда будет применяться наш генератор digit(*args), 
мы создадим ф-ю враппер и вернем return wrapper. Когда мы будем вызывать ф-ю дижит, мы будем 
работать внутри враппер result = func(*args, **kwargs) и будем эту функцию вызвыть в func"""

# def func_gen_dec(precision): # на входе параметр - колич во цифр после запятой, при создании декоратора
#     def dec(func):
#         def wrapper(*args, **kwargs):  # ф-я - заменитель, здесь мы будем вызывать функцию digit(*args)
#             started_at =  time.time()
#             result = func(*args, **kwargs)
#             ended_at = time.time()
#             elapses = round(ended_at - started_at, precision)  # отличия в этой строке
#             print(f'Функция работала {elapses} секунды')
#             return result
#         return wrapper
#     return dec
# # Функция, котораря возвращает декоратор

import time
import sys

# """Все тот же генератор декоратора, просто дополненный строчками"""
#
# def func_gen_dec(precision):
#     print("Получили точность, с которой надо выводить рез-т")
#     print("Начинаем создавать декоратор")
#     def dec(func):
#         print(f"Декоратор принял на вход функцию, которую надо отдекорировать -{func}")
#         print("Начинаем создавать функцию-обертку")
#         def wrapper(*args, **kwargs):  # ф-я - заменитель, здесь мы будем вызывать функцию digit(*args)
#             print("Мы в функции-обертке, которая заместит реальную функцию")
#             print("Засекаем время")
#             started_at =  time.time()
#             print("запускаем реал ф-ю с переданными в ф-ю-обертку параметрами и запоминаем рез-т")
#             result = func(*args, **kwargs)
#             print("Определяем затраченное время и выводим его")
#             ended_at = time.time()
#             print(f"Вот тут-то и пригодится прекисион (== -{precision}- он запомнился в замыкании surrogate")
#             elapses = round(ended_at - started_at, precision)  # отличия в этой строке
#             print(f'Функция работала {elapses} секунды')
#             print('Возвращаем результат, который вернула реальная функция')
#             return result
#         print('Декоратор создал функцию-обертку и возвращает ее')
#         return wrapper
#     print('Декоратор создан и пора его вернуть')
#     return dec
#
# # Функция, котораря возвращает декоратор
#
# @func_gen_dec(precision=6) # мы можем прямо тут указать параметр, при генерировании декоратора       декоратора
# def digits(*args):
#     total = 1
#     for number in args:
#         total *=  number ** 5000
#         return len(str(total))  # эта ф возвращает длину строчки
#
# # sys.set_int_max_str_digits(10**5) # увеличиваем максимал длину строчки
#
# time_track_precision_6 = func_gen_dec(precision=2)
# digits = time_track_precision_6(digits)
# result = digits(3141, 5926, 2718, 2818)
# print(result)

